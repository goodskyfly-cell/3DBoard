<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>FIBA 3D 戰術板 - 籃球與三分線完整版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #ui-left { position: absolute; top: 15px; left: 15px; z-index: 100; display: flex; flex-direction: column; gap: 8px; }
        button { padding: 10px; font-size: 13px; cursor: pointer; border: none; border-radius: 6px; font-weight: bold; background: rgba(255, 255, 255, 0.95); box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .btn-rec { background: #ff3333; color: white; }
        .btn-next { background: #ff9900; color: white; display: none; }
        .btn-play { background: #28a745; color: white; }
        #status { position: absolute; bottom: 20px; width: 100%; text-align: center; color: white; pointer-events: none; }
    </style>
</head>
<body>

    <div id="ui-left">
        <button onclick="changeView('top')">鳥瞰視角</button>
        <button onclick="changeView('side')">戰術視角 (正面)</button>
        <button onclick="changeView('45left')">左側 45°</button>
        <button onclick="changeView('45right')">右側 45°</button>
        <hr style="border:0; border-top:1px solid #444;">
        <button id="recBtn" class="btn-rec" onclick="toggleRecording()">● 開始分格錄製</button>
        <button id="nextBtn" class="btn-next" onclick="recordNextStage()">＋ 錄製下一格</button>
        <button id="playBtn" class="btn-play" onclick="playFullTactic()" disabled>▶ 播放完整戰術</button>
    </div>

    <div id="status">狀態：三分線已修復，籃球已加入</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let movableObjects = [], clickTargets = [], stages = [];
        let isPlaying = false, playStartTime = 0;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersection = new THREE.Vector3();
        const offset = new THREE.Vector3();
        let selectedObject = null;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 18, 25);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 2.5));

            scene.add(createFIBAField());
            addHoop(14, 0); addHoop(-14, 0);

            // 生成球員
            for(let i=1; i<=5; i++) {
                createPlayer(-7, -6 + i*2.2, 0xcc0000, i.toString());
                createPlayer(7, -6 + i*2.2, 0x0000cc, i.toString());
            }

            // --- 增加籃球 ---
            createBall(0, 0);

            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.onresize = () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            };
        }

        // --- 拖拽邏輯 ---
        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(clickTargets);
            if (intersects.length > 0) {
                controls.enabled = false;
                selectedObject = intersects[0].object.parent; 
                if (raycaster.ray.intersectPlane(plane, intersection)) {
                    offset.copy(intersection).sub(selectedObject.position);
                }
            }
        }

        function onMouseMove(event) {
            if (!selectedObject) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (raycaster.ray.intersectPlane(plane, intersection)) {
                selectedObject.position.copy(intersection.sub(offset));
                selectedObject.position.y = 0; 
            }
        }

        function onMouseUp() { selectedObject = null; controls.enabled = true; }

        // --- 球場繪製 (修復三分線) ---
        function createFIBAField() {
            const canvas = document.createElement('canvas');
            canvas.width = 2800; canvas.height = 1500;
            const ctx = canvas.getContext('2d');
            
            // 地板背景
            ctx.fillStyle = '#bc9b70'; ctx.fillRect(0, 0, 2800, 1500);
            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 12;

            // 邊線與中線
            ctx.strokeRect(0, 0, 2800, 1500);
            ctx.beginPath(); ctx.moveTo(1400, 0); ctx.lineTo(1400, 1500); ctx.stroke();
            ctx.beginPath(); ctx.arc(1400, 750, 180, 0, Math.PI * 2); ctx.stroke();

            // 兩側禁區與三分線
            [0, 2800].forEach(x => {
                const d = x === 0 ? 1 : -1;
                // 禁區
                ctx.strokeRect(x, 505, 580 * d, 490);
                // 罰球弧
                ctx.beginPath(); ctx.arc(x + 580 * d, 750, 180, -Math.PI/2, Math.PI/2, x !== 0); ctx.stroke();
                
                // 三分線 (FIBA: 底線延伸 0.9m, 半徑 6.75m)
                ctx.beginPath();
                ctx.moveTo(x, 90); 
                ctx.lineTo(x + 299 * d, 90); // 底線直線部分
                ctx.arc(x + 157.5 * d, 750, 675, -1.39, 1.39, x !== 0); // 弧線部分
                ctx.lineTo(x, 1410); // 另一側底線直線
                ctx.stroke();
            });

            const texture = new THREE.CanvasTexture(canvas);
            const planeMesh = new THREE.Mesh(new THREE.PlaneGeometry(28, 15), new THREE.MeshLambertMaterial({ map: texture }));
            planeMesh.rotation.x = -Math.PI / 2;
            return planeMesh;
        }

        function createBall(x, z) {
            const group = new THREE.Group();
            const ball = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 32, 32),
                new THREE.MeshPhongMaterial({ color: 0xff6600 }) // 橘色籃球
            );
            ball.position.y = 0.2; 
            group.add(ball);
            clickTargets.push(ball); // 加入點擊檢測
            group.position.set(x, 0, z);
            scene.add(group);
            movableObjects.push(group);
        }

        function createPlayer(x, z, color, num) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 0.8, 4, 8), new THREE.MeshPhongMaterial({ color }));
            body.position.y = 0.4; group.add(body); clickTargets.push(body);
            const nCanvas = document.createElement('canvas'); nCanvas.width = 64; nCanvas.height = 64;
            const nCtx = nCanvas.getContext('2d'); nCtx.fillStyle = 'white'; nCtx.font = 'bold 40px Arial'; nCtx.textAlign = 'center';
            nCtx.fillText(num, 32, 45);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(nCanvas) }));
            sprite.position.y = 1.4; sprite.scale.set(0.8, 0.8, 1); group.add(sprite);
            group.position.set(x, 0, z); scene.add(group);
            movableObjects.push(group);
        }

        // --- 錄製與視角功能 ---
        window.toggleRecording = () => {
            const btn = document.getElementById('recBtn');
            const nextBtn = document.getElementById('nextBtn');
            if (btn.innerText.includes("開始")) {
                stages = []; recordNextStage();
                btn.innerText = "■ 結束錄製"; nextBtn.style.display = "block";
            } else {
                btn.innerText = "● 開始分格錄製"; nextBtn.style.display = "none";
                document.getElementById('playBtn').disabled = false;
            }
        };

        window.recordNextStage = () => {
            stages.push(movableObjects.map(g => ({ x: g.position.x, z: g.position.z })));
            document.getElementById('status').innerText = `已紀錄第 ${stages.length} 格位置 (含籃球)`;
        };

        window.playFullTactic = () => {
            if (stages.length < 2) return;
            isPlaying = true; playStartTime = Date.now();
        };

        function animate() {
            requestAnimationFrame(animate);
            if (isPlaying) {
                const progress = (Date.now() - playStartTime) / 1000;
                const idx = Math.floor(progress);
                const ratio = progress - idx;
                if (idx < stages.length - 1) {
                    movableObjects.forEach((g, i) => {
                        g.position.x = stages[idx][i].x + (stages[idx+1][i].x - stages[idx][i].x) * ratio;
                        g.position.z = stages[idx][i].z + (stages[idx+1][i].z - stages[idx][i].z) * ratio;
                    });
                } else { isPlaying = false; }
            }
            controls.update();
            renderer.render(scene, camera);
        }

        function addHoop(baseX, z) {
            const group = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.3), new THREE.MeshPhongMaterial({ color: 0x222222 }));
            pole.position.set(0.5 * (baseX > 0 ? 1 : -1), 2, 0); group.add(pole);
            const backboard = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 1.8), new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 }));
            backboard.position.set(-1.2 * (baseX > 0 ? 1 : -1), 3.2, 0); group.add(backboard);
            const rim = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.03, 12, 24), new THREE.MeshPhongMaterial({ color: 0xff4400 }));
            rim.rotation.x = Math.PI/2; rim.position.set(-1.575 * (baseX > 0 ? 1 : -1), 3.05, 0); group.add(rim);
            group.position.set(baseX, 0, z); scene.add(group);
        }

        window.changeView = (v) => {
            if(v === 'top') camera.position.set(0, 32, 0);
            if(v === 'side') camera.position.set(0, 18, 25);
            if(v === '45left') camera.position.set(-22, 16, 18);
            if(v === '45right') camera.position.set(22, 16, 18);
            controls.target.set(0,0,0); controls.update();
        };
    </script>
</body>
</html>